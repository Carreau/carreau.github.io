<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="Random, often unfinished thoughts about things, mostly programming and Python">
<meta name="viewport" content="width=device-width">
<title>Random Thoughts (old posts, page 3) | Random Thoughts</title>
<link href="assets/css/bitter.css" rel="stylesheet" type="text/css">
<link href="assets/css/ipython.min.css" rel="stylesheet" type="text/css">
<link href="assets/css/main.css" rel="stylesheet" type="text/css">
<link href="assets/css/rst.css" rel="stylesheet" type="text/css">
<link href="assets/css/code.css" rel="stylesheet" type="text/css">
<link href="assets/css/nikola_ipython.css" rel="stylesheet" type="text/css">
<link rel="alternate" type="application/rss+xml" title="RSS" href="rss.xml">
<link rel="canonical" href="https://carreau.github.io/index-3.html">
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    },
    displayAlign: 'left', // Change this to 'center' to center equations.
    "HTML-CSS": {
        styles: {'.MathJax_Display': {"margin": 0}}
    }
});
</script><!--[if lt IE 9]><script src="/assets/js/html5.js"></script><![endif]-->
</head>
<body>
    <section class="social"><ul>
<li><a href="pages/me.html" title="Me"><img src="https://avatars2.githubusercontent.com/u/335567?v=3&amp;s=400"></a></li>
        <li><a href="index.html" title="Home"><i class="icon-home"></i></a></li>
        <li><a href="pages/me.html" title="Me"><i class="icon-user"></i></a></li>
        <li><a href="rss.xml" title="RSS"><i class="icon-rss"></i></a></li>
        <li><a href="https://twitter.com/mbussonn" title="My Twitter"><i class="icon-twitter"></i></a></li>
        <li><a href="https://github.com/Carreau" title="Me on Github"><i class="icon-github"></i></a></li>
        <li><a href="https://www.linkedin.com/in/matthias-bussonnier-2512256a" title="Linked In"><i class="icon-linkedin"></i></a></li>
        <li><a href="https://keybase.io/mbussonn/" title="Keybase"><i class="icon-key"></i></a></li>
        <li><a href="https://stackoverflow.com/users/137794/matt" title="StackOverflow"><i class="icon-stackexchange"></i></a></li>
        <li><a href="archive.html" title="Archives"><i class="icon-archive"></i></a></li>

        </ul></section><section class="page-content"><div class="content" rel="main">
        <div class="post">
            <h1 class="title"><a href="posts/25-Changing-ByteString-REPR/">Changing ByteStr REPR</a></h1>
            <div class="meta">
                <div class="authordate">
                    <time class="timeago" datetime="2017-01-16T10:00:00+00:00">2017-01-16 10:00</time>
</div>
                <div class="stats">
                    
                </div>
                
            </div>
            <div class="body">
                A recent rebutal against Python 3 was recently written by the (in)famous Zed Shaw, with many responses to various arguments and counter arguments.
One particular topic which caught my eye was the bytearray vs unicodearray debate. I'll try explicitely avoid the term str/string/bytes/unicode naming as it is (IMHO) confusing, but that's a debate for another time. If one pay attention to above debates, you might see that there are about two camps:

bytearray and unicodearray are two different things, and we should never convert from one to the other. (that's rought the Pro-Python-3 camp)
bytearray and unicodearray are similar enough in most cases that we should do the magic for users. 

I'm greatly exagerating here and the following is neither for one side or another, I have my personal preference of what I think is good, but that's irrelevant for now. Note that both sides argue that their preference is better for beginners.







You can often find posts trying to explain the misconception string/str/bytes, like this one which keep insisting on the fact that str in python 3 is far different from bytes.







The mistake in the REPR¶






I have one theory that the bytes/str issue is not in their behavior, but in their REPR. The REPR is in the end the main informatin communication channel between the object and the brain of the programmer, user. Also, Python "ducktyped", and you have to admit that bytes and str kinda look similar when printed, so assuming they should behave in similar way is not far fetched. I'm not saying that user will conciously assume bytes/str are the same. I'm saying that human brain inherently may do such association.
From the top of your head, what does requests.get(url).content returns ?






In [1]:

    
import requests_cache
import requests
requests_cache.install_cache('cachedb.tmp')


    






In [2]:

    
requests.get('http://swapi.co/api/people/1').content


    









    Out[2]:





b'{"name":"Luke Skywalker","height":"172","mass":"77","hair_color":"blond","skin_color":"fair","eye_color":"blue","birth_year":"19BBY","gender":"male","homeworld":"http://swapi.co/api/planets/1/","films":["http://swapi.co/api/films/6/","http://swapi.co/api/films/3/","http://swapi.co/api/films/2/","http://swapi.co/api/films/1/","http://swapi.co/api/films/7/"],"species":["http://swapi.co/api/species/1/"],"vehicles":["http://swapi.co/api/vehicles/14/","http://swapi.co/api/vehicles/30/"],"starships":["http://swapi.co/api/starships/12/","http://swapi.co/api/starships/22/"],"created":"2014-12-09T13:50:51.644000Z","edited":"2014-12-20T21:17:56.891000Z","url":"http://swapi.co/api/people/1/"}'











... bytes...
I'm pretty sure you glanced ahead in this post and probaly thought it was "Text", even probably in this case Json. It might be invalid Json, I'm pretty sure you cannot tell.
Why does it returns bytes ? Because it could fetch an image:






In [3]:

    
requests.get('https://avatars0.githubusercontent.com/u/335567').content[:200]


    









    Out[3]:





b"\x89PNG\r\n\x1a\n\x00\x00\x00\rIHDR\x00\x00\x01\xcc\x00\x00\x01\xcc\x08\x06\x00\x00\x00X\xdb\x98\x86\x00\x00 \x00IDATx\xda\xac\xbdy\x93\x1b\xb9\xb2\xf6\xf7K\x00\xb5\x90\xbdH\xa3\x99\xb9s7\xbf\xf1:\x1c\x0e/\xdf\xff\xdb8\xec\xb0}\xd79g4Rw\xb3IV\x15\x80\xf4\x1f@\xedUl\xea\\w\x84\xa65-6Y\x85\x02ry\xf2\xc9'\xa5\xfe\x9f\xfeGE\x04#\x821\x061\x16c\x0c\xc6XD\x0c\x02\xa0\x8a\x8a\x801\xa4\x1f\x08\x880\xfdRUD\x04\xd5\xfe\xff#6z\x8c*\xaa\x82\x88\xe0C \x84@\xf7~\xa6yy\xc5=&gt;Q&gt;~\xe6\xe1\xf3g~\xfd\xa7\x7f\xc28\x07\xb6\x00\x84h-\x88A1(\xe0U\xd2\xfb\xb8t\r1("











And if you decode the first request ?






In [4]:

    
requests.get('http://swapi.co/api/people/2').content.decode()


    









    Out[4]:





'{"name":"C-3PO","height":"167","mass":"75","hair_color":"n/a","skin_color":"gold","eye_color":"yellow","birth_year":"112BBY","gender":"n/a","homeworld":"http://swapi.co/api/planets/1/","films":["http://swapi.co/api/films/5/","http://swapi.co/api/films/4/","http://swapi.co/api/films/6/","http://swapi.co/api/films/3/","http://swapi.co/api/films/2/","http://swapi.co/api/films/1/"],"species":["http://swapi.co/api/species/2/"],"vehicles":[],"starships":[],"created":"2014-12-10T15:10:51.357000Z","edited":"2014-12-20T21:17:50.309000Z","url":"http://swapi.co/api/people/2/"}'











Well that looks the same (except leading b...). Go explain a beginner that the 2 above are totally different things, while they already struggle with 0 base indexing, iterators, and the syntax of the language.







Changing the repr¶






Lets revert the repr of bytesarray to better represent what they are.  IPython allows to change object repr easily:






In [5]:

    
text_formatter = get_ipython().display_formatter.formatters['text/plain']


    






In [6]:

    
def _print_bytestr(arg, p, cycle):
    p.text('<bytesbytesbytesbytesbytes>')        
text_formatter.for_type(bytes, _print_bytestr)


    









    Out[6]:





<function ipython.lib.pretty._repr_pprint>










In [7]:

    
requests.get('http://swapi.co/api/people/4').content


    









    Out[7]:





<bytesbytesbytesbytesbytes>











Make a usefull repr¶






<bytesbytesbytes> may not an  usefull repr, so let's try to make a repr, that:

Convey bytes are, in genral not text.
Let us peak into the content to guess what it is
Push the user to .decode() if necessary.

Generally in Python objects have a repr which start with .
As the _quoted representation of the object may be really long, we can ellide it.
A common representation of bytes could be binary, but it's not really compact. Hex, compact but more difficult to read, and make peaking at the content hart when it could be ASCII. So let's go with ASCII reprentation where we escape non ASCII caracterd.






In [8]:

    
ellide = lambda s: s if (len(s) &lt; 75) else  s[0:50]+'...'+s[-16:]


    






In [9]:

    
def _print_bytestr(arg, p, cycle):
    p.text('<bytes at>'.format(hex(id(arg))))       
text_formatter.for_type(bytes, _print_bytestr)


    









    Out[9]:





<function __main__._print_bytestr>










In [10]:

    
requests.get('http://swapi.co/api/people/12').content


    









    Out[10]:





<bytes b tarkin at>










In [11]:

    
requests.get('http://swapi.co/api/people/12').content.decode()


    









    Out[11]:





'{"name":"Wilhuff Tarkin","height":"180","mass":"unknown","hair_color":"auburn, grey","skin_color":"fair","eye_color":"blue","birth_year":"64BBY","gender":"male","homeworld":"http://swapi.co/api/planets/21/","films":["http://swapi.co/api/films/1/","http://swapi.co/api/films/6/"],"species":["http://swapi.co/api/species/1/"],"vehicles":[],"starships":[],"created":"2014-12-10T16:26:56.138000Z","edited":"2014-12-20T21:17:50.330000Z","url":"http://swapi.co/api/people/12/"}'











Advantage: It is not gobbledygook anymore when getting binary resources !






In [12]:

    
requests.get('https://avatars0.githubusercontent.com/u/335567').content


    









    Out[12]:





<bytes b at></bytes></bytes></function></bytes></bytesbytesbytes></bytesbytesbytesbytesbytes></function></bytesbytesbytesbytesbytes>
</div>
        </div>
        <div class="post">
            <h1 class="title"><a href="posts/25-remaping-notebook-shortcuts.md/">Remapping notebook shortcuts</a></h1>
            <div class="meta">
                <div class="authordate">
                    <time class="timeago" datetime="2016-11-30T11:00:00+00:00">2016-11-30 11:00</time>
</div>
                <div class="stats">
                    
                </div>
                
            </div>
            <div class="body">
                As Jupyter notebook run in a browser for technical and practical
reasons we only have a limited number of shortcuts available and
choices need to be made. Often this choices may conflict with browser
shortcut, and you might need to remap it. 
Today I was inform by Stefan van Der Walt that Cmd-Shift-P conflict
for Firefox. It is mapped both to open the Command palette for the
notebook and  open a new Private Browsing window. 
Using Private Browsing windows is extremely useful. When developing
a website you might want to look at it without being logged in, and
with an empty cache. So let see how we can remap the Jupyter notebook
shortcut. 
TL; DR;
Use the following in your ~/.jupyter/custom/custom.js :
require(['base/js/namespace'], function(Jupyter){
  // we might want to but that in a callback on wait for 
  // en even telling us the ntebook is ready.
  console.log('== remaping command palette shortcut ==')
  // note that meta is the command key on mac.
  var source_sht = 'meta-shift-p'
  var target_sht = 'meta-/'
  var cmd_shortcuts = Jupyter.keyboard_manager.command_shortcuts;
  var action_name = cmd_shortcuts.get_shortcut(source_sht)
  cmd_shortcuts.add_shortcut(target_sht, action_name)
  cmd_shortcuts.remove_shortcut(source_sht)
  console.log('== ', action_name, 'remaped from', source_sht, 'to', target_sht )
})


details
We need to use require and register a callback once the notebook is
loaded:
require(['base/js/namespace'], function(Jupyter){
  ...
})


Here we grab the main namespace and name it Jupyter.
Then get the object that hold the various shortcuts: var
cmd_shortcuts = Jupyter.keyboard_manager.command_shortcuts.
Shortcuts are define by sequence on keys with modifiers. Modifiers are
dash-separated (need to be pressed at the same time). Sequence are
comma separated. Example quiting in vim would be esc,;,w,q, in emacs
ctrl-x,ctrl-c. 
Here we want to unbind meta-shift-p (p is lowercase despite shift
being pressed) and bind meta-/ (The shortcut Stefan wants). Note
that meta- is the command key on mac.
We need to get the current command bound to this shortcut
(cmd_shortcuts.get_shortcut(source_sht)). You could hardcode the
name of the command but it may change a bit depending on notebook
version (this is not yet public API). Here it is jupyter-notebook:show-command-palette. 
You now bind it to your new shortcut:
cmd_shortcuts.add_shortcut('meta-/', action_name)


And finally unbind the original one
cmd_shortcuts.remove_shortcut('meta-shift-p')


UI reflect your changes !
If you open the command palette, you should see that the Show command
palette command now display Command-/ as its shortcut !
Future
We are working on an interface to edit shortcuts directly from within
the UI and not to have to write a single line of code !
Questions, feedback and fixes welcomed
            </div>
        </div>
        <div class="post">
            <h1 class="title"><a href="posts/24-Viridisify/">Viridisify</a></h1>
            <div class="meta">
                <div class="authordate">
                    <time class="timeago" datetime="2016-10-07T20:00:00+00:00">2016-10-07 20:00</time>
</div>
                <div class="stats">
                    
                </div>
                
            </div>
            <div class="body">
                Viridisify¶






As usual this is available and as been written as a jupyter notebook if you like to play with the code feel free to fork it.








The jet colormap (AKA "rainbow") is ubiquitous, there are a lot of controverse as to wether it is (from far)  the best one. And better options have been designed.
The question is, if you have a graph that use a specific colormap, and you would prefer for it to use another one; what do you do ?
Well is you have th eunderlying data that's easy, but it's not always the case.
So how to remap a plot which has a non perceptually uniform colormap using another ? What's happend if yhere are encoding artificats and my pixels colors are slightly off ?
I came up with a prototype a few month ago, and was asked recently by @stefanv to "correct" a animated plot of huricane Matthew, where the "jet" colormap seem to provide an illusion of growth:
https://twitter.com/stefanvdwalt/status/784429257556492288
Let's see how we can convert a "Jet" image to a viridis based one. We'll first need some assumptions:

This assume that you "know" the initial color map of a plot, and that the emcoding/compressing process of the plot will not change the colors "too much".
There are pixels in the image which are not part of the colormap (typically text, axex, cat pictures....)

We will try to remap all the pixels that fall not "too far" from the initial colormap to the new colormap.






In [1]:

    
%matplotlib inline
import matplotlib
import matplotlib.pyplot as plt
import numpy as np


    






In [2]:

    
import matplotlib.colors as colors


    






In [3]:

    
!rm *.png *.gif out*


    









    



rm: output.gif: No such file or directory











I used the following to convert from mp4 to image sequence (8 fps determined manually). 
Sequence of images to video, and video to gif (quality is better than to gif dirrectly):

$ ffmpeg -i INPUT.mp4 -r 8 -f image2 img%02d.png
$ ffmpeg -framerate 8 -i vir-img%02d.png -c:v libx264 -r 8 -pix_fmt yuv420p out.mp4
$ ffmpeg -i out.mp4  output.gif






In [4]:

    
%%bash
ffmpeg -i input.mp4 -r 8 -f image2 img%02d.png -loglevel panic


    







Let's take our image without the alpha channel, so only the first 3 components:






In [5]:

    
import matplotlib.image as mpimg
img = mpimg.imread('img01.png')[:,:,:3]


    






In [6]:

    
fig, ax = plt.subplots()
ax.imshow(img)
fig.set_figheight(10)
fig.set_figwidth(10)


    









    

















As you can see it does use "Jet" (most likely),
let's look at the repartitions of pixels on the RGB space...






In [7]:

    
import numpy as np
from mpl_toolkits.mplot3d import Axes3D

import matplotlib.pyplot as plt


    






In [8]:

    
def rep(im, cin=None, sub=128):
    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')
    pp = im.reshape((-1,3)).T[:,::300]
    
    if cin:
        cmapin = plt.get_cmap(cin)
        cmap256 = colors.makeMappingArray(sub, cmapin)[:, :3].T
        ax.scatter(cmap256[0], cmap256[1], cmap256[2], marker='.', label='colormap', c=range(sub), cmap=cin, edgecolor=None)
    
    ax.scatter(pp[0], pp[1], pp[2], c=pp.T, marker='+')
    
    ax.set_xlabel('R')
    ax.set_ylabel('G')
    ax.set_zlabel('B')
    ax.set_title('Color of pixels')
    if cin:
        ax.legend()
    return ax
    
ax = rep(img)


    









    

















We can see a specific clusers of pixel, let's plot the location of our "Jet" colormap and a diagonal of "gray".
We can guess the effect of various compressions artifacts have jittered the pixels slightly away from their original location.
Let's look at where the jet colormap is supposed to fall:






In [9]:

    
rep(img, 'jet')


    









    Out[9]:





<matplotlib.axes._subplots.axes3dsubplot at>






    

















Ok, that's pretty accurate, we also see that our selected graph does nto use the full extent of jet.







in order to find all the pixels that uses "Jet" efficiently we will use scipy.spatial.KDTree in the colorspace. In particular we will subsample the initial colormap in sub=256 subsamples, and collect only pixels that are within d=0.2 of this subsample, and map each of these pixels to the closer subsample.
As we know the subsampling of the initial colormap, we can also determine the output colors.
The Pixels that are "too far" from the pixels of the colormap are keep unchanged.
increasing 256 to higher value will give a smoother final colormap.






In [10]:

    
from scipy.spatial import cKDTree


    






In [11]:

    
def convert(sub=256, d=0.2, cin='jet', cout='viridis', img=img, show=True):
    viridis = plt.get_cmap(cout)
    cmapin = plt.get_cmap(cin)
    cmap256 = colors.makeMappingArray(sub, cmapin)[:, :3]
    original_shape = img.shape
    img_data = img.reshape((-1,3))
    
    # this will efficiently find the pixels "close" to jet
    # and assign them to which point (from 1 to 256) they are on the colormap.
    K = cKDTree(cmap256)
    res = K.query(img_data, distance_upper_bound=d)
    
    indices = res[1]
    l = len(cmap256)
    indices = indices.reshape(original_shape[:2])
    remapped = indices

    indices.max()

    mask = (indices == l)

    remapped = remapped / (l-1)
    mask = np.stack( [mask]*3, axis=-1)

    # here we add only these pixel and plot them again with viridis.
    blend = np.where(mask, img, viridis(remapped)[:,:,:3])
    if show:
        fig, ax = plt.subplots()
        fig.set_figheight(10)
        fig.set_figwidth(10)
        ax.imshow(blend)
    return blend


    






In [12]:

    
res = convert(img=img)
rep(res)


    









    Out[12]:





<matplotlib.axes._subplots.axes3dsubplot at>






    












    

















Let's loot at what happend if we decrease our leniency for the "proximity" of each pixel to the jet colormap:






In [13]:

    
rep(convert(img=img, d=0.05))


    









    Out[13]:





<matplotlib.axes._subplots.axes3dsubplot at>






    












    

















Ouch ve definitively missed some pixels.






In [14]:

    
rep(convert(img=img, sub=8, d=0.4))


    









    Out[14]:





<matplotlib.axes._subplots.axes3dsubplot at>






    












    

















Subsampling to 8 colors (see above) forces us to increase or distance to accept points, and hint the non-linearity of "Jet" as seen in the colorbar.






In [15]:

    
rep(convert(img=img, sub=256, d=0.7))


    









    Out[15]:





<matplotlib.axes._subplots.axes3dsubplot at>






    












    

















Beeing too lenient on the distance between the colormap and the pixel will change the color of undesired part of our image.
Also look at our clean image that does nto scatter our pixel in RGB space !







Ok, we've played enough, let's convert all our images and re-make a gif/mp4 out of it...






In [16]:

    
tpl = 'img%02d.png'
tplv = 'vir-img%02d.png'
for i in range(1,18):
    img = mpimg.imread(tpl%i)[:,:,:3]
    vimg = convert(show=False, img=img)
    mpimg.imsave(tplv %i, vimg)


    






In [17]:

    
%%bash
ffmpeg -framerate 8 -i vir-img%02d.png -c:v libx264 -r 8 -pix_fmt yuv420p out.mp4 -y -loglevel panic


    






In [18]:

    
%%bash
ffmpeg -i out.mp4  output.gif -y -loglevel panic


    







Enjoy the result, and see how the north part of the huricane does not look like getting that much increase in intensity !
https://twitter.com/Mbussonn/status/784447098963972098
It's not a reason not to stay safe from huricanes.

Thanks to Stefan Van der Walt, and Nathaniel Smith for inspiration and helpful discussion.

Notes:
Michael Ayes asks:
that’s cool, but technically, that’s viridis_r, isn’t it?

That's discutable as I do a map from Jet to Viridis, the authors of the initial  graph seem to have user jet_r (reversed jet) so the final version looks like viridis_r (reversed viridis). More generally if the the original graph had used f(jet), then the final version woudl be close to f(viridis).
As usual please feel free to ask questions or send me updates, as my english is likely far from perfect.
            </matplotlib.axes._subplots.axes3dsubplot></matplotlib.axes._subplots.axes3dsubplot></matplotlib.axes._subplots.axes3dsubplot></matplotlib.axes._subplots.axes3dsubplot></matplotlib.axes._subplots.axes3dsubplot>
</div>
        </div>
        <div class="post">
            <h1 class="title"><a href="posts/23-Cross-Language-Integration/">Cross Language Integration</a></h1>
            <div class="meta">
                <div class="authordate">
                    <time class="timeago" datetime="2016-10-04T17:20:00+00:00">2016-10-04 17:20</time>
</div>
                <div class="stats">
                    
                </div>
                
            </div>
            <div class="body">
                Jupyter and multiple Languages¶






Note: This has been written as a notebook so you can download it to run it yourself using jupyter or nteract, view it on GitHub, or on nbviewer if you prefer the classical notebook rendering. It originally should have appeared on my blog.
I would be happy to know if you can get it to work on binder.

[UPDATE]
Thanks to Michael Pacer for copy-editting this. 
Also note that this notebook is basedaround multiple example that have been written by various people across many years.

An often requested feature for the Jupyter Notebook is the ability to have multiple kernels, often in many languages, for a single notebook.
While the request in spirit is a perfectly valid one, it is often a misunderstanding of what having a single kernel means. In particular having multiple language is often easier if you have a single process which handle the dispatching of various instructions to potentially multiple underlying languages. It is possible to do that in a Single Kernel which does orchestrate dispatching instruction and moving data around.
Whether the multiple languages that get orchestrated together are remote processes, or simply library calls or more complex mechanisms becomes an implementation detail.
Python is known to be a good "glue" language, and over the year the IPython kernel have seen a growing number of extensions showing that dynamic cross language integration can be seamless form the point of view of the user.
In the following we only scratch the surface of what is possible across a variety of languages. The approach shown here is one among many. The Calysto organisation for example has several projects taking different approaches on the problem.
In the following I will show a quick overview on how you can in single notebook interact with many languages, via subprocess call (Bash, Ruby), Common Foreign function interface (C, Rust, Fortran, ...), or even crazier approaches (Julia).







IPython and cross language integration¶






The rest of this is mostly a demo on how cross-language integration works in a Jupyter notebook by using the features of the Reference IPython Kernel implementation. These features are completely handled in the kernel so need to be reimplemented on a per-kernel basis. Though they also work on pure terminal IPython, nbconvert or any other programmatic use of IPython.
Most of what you will see here are just thin wrappers around already existing libraries. These libraries (and their respective authors) do all the heavy lifting. I just show how seamless a cross language environment can be from the user point of view. The installation of these library might not be easy either and getting all these language to play together can be complex task. It is though becoming easier and easier.
The term just does not imply that the wrappers are simple, or easy to write. It indicate that the wrappers are far from being complete. What is shown here is completely doable using standard Python syntax and bit of manual work. SO what you'll see here is mostly convenience.







The good old example of Fibonacci¶






Understanding the multiple languages themselves is not necessary; most of the code here should self explanatory and straightforward. We'll define many function that compute the nth Fibonacci number more or less efficiently. We'll define them either using the classic recursive implementation, or sometime using an unrolled optimized version. As a reminder the Fibonacci sequence is defines a the following:
$$ F_n = \begin{cases} 1 &amp;\mbox{if } n \leq 2 \\ 
F_{n-1}+F_{n-2} &amp; \mbox{otherwise }\end{cases}$$






The fact that we calculate the Fibonacci sequence as little importance, except that the value of $F_n$ can grow really fast in $O(e^n)$ if I remember correctly. And the recursive implementation will have a hard time getting beyond (n=100) as the number of call will be greater than $O(e^n)$ as well. Be careful especially if you calculate $F_{F_n}$ or more composition. Remembering that n=5 is stable via $F$ might be useful.
Here are the first terms of the Fibonacci sequence:

1
1
1+1 = 2
2+1 = 3
3+2 = 5
5+3 = 8
8+5 = 13
...








Basic Python cross-language integration¶





In [1]:

    
import sys
sys.version_info


    









    Out[1]:





sys.version_info(major=3, minor=5, micro=2, releaselevel='final', serial=0)











Python offer many facilities to call into other languages, whether we "shell-out" or use the C-API. The easiest for the end user is often to use subprocess , with the recently added run command. Though it might be annoying to define all foreign code in strings and calling the subprocess run function manually.







This is why in the following you will see 2 constructs:

optional_python_lhs = %language (language RHS expression)
As well as

%%language --cli like arguments
A block:
  containing expressions and statement
from another:
  language







IPython define these which are called Magics.  A single percent :  %something for line magics, act only on the rest of the line, and cells magics (start with %%)







One example of line magic is %timeit, which runs the following statement multiple time to get statistics about runtime:






In [2]:

    
%timeit [x for x in range(1000)]


    









    



10000 loops, best of 3: 34.9 µs per loop











Streamlining calling subprocess¶






The IPython team special cased a couple of these for foreign languages, here ruby. We define the fibonacci function, compute the 15th value, print it to standard out from Ruby, and capture the value variable in the python fib15.






In [3]:

    
%%ruby --out fib15
def fibonacci( n )
  return  n  if ( 0..1 ).include? n
  ( fibonacci( n - 1 ) + fibonacci( n - 2 ) )
end
puts fibonacci( 15 )


    






In [4]:

    
fib15


    









    Out[4]:





'610\n'











Now from with Python we can do a crude parsing of the previous string output, and get the value of Fibonacci of 15.






In [5]:

    
int(fib15.strip())


    









    Out[5]:





610











Ok, that's somewhat useful, but not really that much. It's convenient for self contain code. You cannot pass variable in... or can't you ?







Send variables in¶






Calling subprocess can be quite cumbersome when working interactively, we saw above that %% cells-magics can be of help, but you might want to shell out in the middle of a python function. Let's create a bunch of random file-names and fake some subprocess operations with it.






In [6]:

    
import random
import string

def rand_names(k=10,l=10):
    for i in range(k):
        yield '_' + ''.join(random.choice(string.ascii_letters) for i in range(l))+'.o'


    







The !something expression is – for the purpose of these demo – equivalent to %sh something $variable where $variable is looked up in locals() and replaced by it's __repr__






In [7]:

    
for f in rand_names():
    print('creating file',f)
    !touch $f


    









    



creating file _XiKZxtsLwX.o
creating file _DKCjzvlTuF.o
creating file _ShTGoJMxCp.o
creating file _nbockcrTbT.o
creating file _cZnVpuYsxJ.o
creating file _UYxnHlwJwy.o
creating file _fxoVMPQbJV.o
creating file _wJJUbrPzpq.o
creating file _ngMMBxaDkG.o
creating file _uKbssAzHBP.o










In [8]:

    
ls -1 *.o


    









    



_DKCjzvlTuF.o
_ShTGoJMxCp.o
_UYxnHlwJwy.o
_XiKZxtsLwX.o
_cZnVpuYsxJ.o
_fxoVMPQbJV.o
_nbockcrTbT.o
_ngMMBxaDkG.o
_uKbssAzHBP.o
_wJJUbrPzpq.o











We can as well get values back using the ! syntax






In [9]:

    
files = !ls *.o
files


    









    Out[9]:





['_DKCjzvlTuF.o',
 '_ShTGoJMxCp.o',
 '_UYxnHlwJwy.o',
 '_XiKZxtsLwX.o',
 '_cZnVpuYsxJ.o',
 '_fxoVMPQbJV.o',
 '_nbockcrTbT.o',
 '_ngMMBxaDkG.o',
 '_uKbssAzHBP.o',
 '_wJJUbrPzpq.o']










In [10]:

    
!rm -rf  *.{o,c,so} Cargo.* src target


    







(Who said I was going to use rust-lang.org later ?)






In [11]:

    
ls *.o


    









    



ls: *.o: No such file or directory











Ok, our directory is clean !







Add some state¶






Ok, that was kind of cute, fire-up a subprocess, serialize, pipe data in as a string, pipe-data out as a string, kill subprocess... What about something less state-less, or more stateful?







Let's define the fibonacci function in python:






In [12]:

    
def fib(n):
    """
    A simple definition of fibonacci manually unrolled
    """
    if n&lt;2:
        return 1
    x,y = 1,1
    for i in range(n-2):
        x,y = y,x+y
    return y


    






In [13]:

    
[fib(i) for i in range(1,10)]


    









    Out[13]:





[1, 1, 2, 3, 5, 8, 13, 21, 34]











Store the value from 1 to 30 in Y, and graph it.






In [14]:

    
%matplotlib inline
import numpy as np
X = np.arange(1,30)
Y = np.array([fib(x) for x in X])
import matplotlib.pyplot as plt
fig, ax = plt.subplots()
ax.scatter(X, Y)
ax.set_xlabel('n')
ax.set_ylabel('fib(n)')
ax.set_title('The Fibonacci sequence grows fast !')


    









    Out[14]:





<matplotlib.text.text at>






    

















It may not surprise you, but this looks like an exponential, so if we were to look at $log(fib(n))$ × $n$ it would look approximately like a line. We can try to do a linear regression using this model. R is a language many people use to do statistics. So, let's use R.







Let's enable integration between Python and R using the RPy2 python package developed by Laurent Gautier and the rest of the rpy2 team.







(Side note, you might need to change the environment variable passed to your kernel for this to work.
Here is what I had to do only once.)






In [15]:

    
#!a2km add-env 'python 3' DYLD_FALLBACK_LIBRARY_PATH=$HOME/anaconda/pkgs/icu-54.1-0/lib:/Users/bussonniermatthias/anaconda/pkgs/zlib-1.2.8-3/lib 


    






In [16]:

    
import rpy2.rinterface

%load_ext rpy2.ipython


    







The Following will "Send" the X and Y array to R.






In [17]:

    
%Rpush Y X


    







And now let's try to fit a linear model ($ln(Y) = A.X + B$) using R. I'm not a R user myself, so don't take this as idiomatic R.






In [18]:

    
%%R
my_summary = summary(lm(log(Y)~X))
val |t|)    
(Intercept) -0.775851   0.026173  -29.64   &lt;2e-16 ***
X            0.479757   0.001524  314.84   &lt;2e-16 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

Residual standard error: 0.06866 on 27 degrees of freedom
Multiple R-squared:  0.9997,	Adjusted R-squared:  0.9997 
F-statistic: 9.912e+04 on 1 and 27 DF,  p-value: &lt; 2.2e-16













Good, we have now the some statistics on the fit, which also looks good. And we were able to not only send variable to R, but to plot directly from R !







We are happy as $F_n = \left[\frac{\phi^n}{\sqrt 5}\right]$, where [] is closest integer and $\phi = \frac{1+\sqrt 5}{2}$







We can also look at the variables more carefully






In [20]:

    
%%R
val


    









    





              Estimate  Std. Error   t value     Pr(&gt;|t|)
(Intercept) -0.7758510 0.026172673 -29.64355 3.910319e-22
X            0.4797571 0.001523832 314.83597 1.137181e-49












Or even the following that looks more like python






In [21]:

    
%R val


    









    Out[21]:





array([[ -7.75850975e-01,   2.61726725e-02,  -2.96435519e+01,
          3.91031947e-22],
       [  4.79757090e-01,   1.52383191e-03,   3.14835966e+02,
          1.13718145e-49]])











We can even get the variable back from R as Python objects:






In [22]:

    
coefs = %Rget val
y0,k = coefs.T[0]
y0,k


    









    Out[22]:





(-0.77585097534858738, 0.4797570904348315)











That's all from the R part. I hope this shows you some of the power of IPython, both in notebook and command line.







CFFI¶






Great! We were able to send data back and forth! If does not works for all objects, but at least for the basic ones. It requires quite some work from the authors of the underlying library to allow you to do that. Though we are still limited to data. We can't (yet) send functions over which limits the utility.







Mix and Match : C¶






One of the critical point of any code may at some point be performance. Python is known to not be the most performant language, though it is convenient and quick to write and has a large ecosystem. Most of the function you requires are probably available in a package, battle tested and optimized.







You might still need here and there the raw power of an ubiquitous language which is known for its speed when you know how to wield it well: C.
Though one of the disadvantage of C is the (relatively) slow  iteration process due to the necessity of compilation/run part of the cycle. Let see if we can improve that by leveraging the excellent CFFI project, using my own small cffi_magic wrapper.






In [23]:

    
import cffi_magic


    






In [24]:

    
rm -rf *.o *.c *.so Cargo.* src target


    






In [25]:

    
ls *.c *.h *.o


    









    



ls: *.c: No such file or directory
ls: *.h: No such file or directory
ls: *.o: No such file or directory











Using the %%cffi magic we can define in the middle of our python code some C function:






In [26]:

    
%%cffi int cfib(int);

int cfib(int n)
{
    int res=0;
    if (n &lt;= 1){
        res = 1;
    } else {
        res = cfib(n-1)+cfib(n-2);
    }
    return res;
}


    







The first line take the "header" of the function we declare, and the rest of the cell takes the body of this function. The cfib function will automatically be made available to you in the main python namespace.






In [27]:

    
cfib(5)


    









    Out[27]:





8











Oops there is a mistake as we should have fib(5) == 5. Luckily we can redefine the function on the fly. I could edit the above cell, but here as this will be rendered statically for the sake of demo purpose, I'm going to make a second cell:






In [28]:

    
%%cffi int cfib(int);

int cfib(int n)
{
    int res=0;
    if (n &lt;= 2){  /*mistake was here*/
        res = 1;
    } else {
        res = cfib(n-1)+cfib(n-2);
    }
    return res;
}


    






In [29]:

    
cfib(5)


    









    Out[29]:





5











Great ! Let's compare the timing.






In [30]:

    
%timeit cfib(10)


    









    



The slowest run took 73.42 times longer than the fastest. This could mean that an intermediate result is being cached.
1000000 loops, best of 3: 379 ns per loop










In [31]:

    
%timeit fib(10)


    









    



The slowest run took 4.65 times longer than the fastest. This could mean that an intermediate result is being cached.
1000000 loops, best of 3: 853 ns per loop











Not so bad considering the C implementation is recursive, and the Python version is manually hand-rolled.







Implementation detail¶






So how do we do that magically under the hood? The knowledgeable reader is aware that CPython extensions cannot be reloaded. Though here we redefine the function... how come?
Using the user provided code we compile a shared object with a random name, import this as a module and alias using a user friendly name in the __main__ namespace. If the user re-execute we just get a new name, and change the alias mapping.
If one wan to optimize you can use a hash of the codecell string to not recompile if the user hasn't changed the code.






In [32]:

    
ls *.o *.c


    









    



_cffi_cWtAstIlGT.c  _cffi_cWtAstIlGT.o  _cffi_yxGAKIqXRR.c  _cffi_yxGAKIqXRR.o











With this in mind you can guess the same can be done for any language which can be compiled to a shared object, or a dynamically loadable library.







Mix and Match : rust¶






The cffi module also allows you to do the same with Rust, a new language designed by Mozilla, which provide the same C-like level of control, while incorporating more recent understanding of programming and provide better memory safety. Let's see how we would do the same with Rust:






In [33]:

    
%%rust int rfib(int);

#[no_mangle]
pub extern fn rfib(n: i32) -&gt; i32 {
    match n {
        0 =&gt; 1,
        1 =&gt; 1,
        2 =&gt; 1,
        _ =&gt; rfib(n-1)+rfib(n-2)
    }
}


    









    



injecting  rfib in user ns










In [34]:

    
[rfib(x) for x in range(1,10)]


    









    Out[34]:





[1, 1, 2, 3, 5, 8, 13, 21, 34]











I'm not a Rustacean, but the above seem pretty straightforward to me. Again this might not be idiomatic Rust but you should be able to decipher what's above. The same than for C applies.







Still in development¶






Both the C and Rust example shown above use the cffi_magic on which I spent roughly 4 hours total, so the functionalities can be really crude and the documentation minimal at best. Feel free to send PRs if you are interested.







Fortran¶






The fortran magic does the same as above, but has been developed by mgaitan and is slightly older. Again no surprise except you are supposed to mark fortran variable that are used to return the values.






In [35]:

    
%load_ext fortranmagic


    









    



/Users/bussonniermatthias/anaconda/lib/python3.5/site-packages/fortranmagic.py:147: UserWarning: get_ipython_cache_dir has moved to the IPython.paths module since IPython 4.0.
  self._lib_dir = os.path.join(get_ipython_cache_dir(), 'fortran')






    







var element = $('#443bc8d4-0210-478f-bd87-e4490bfd7fc7');
$.getScript("https://raw.github.com/marijnh/CodeMirror/master/mode/fortran/fortran.js", function () {
IPython.config.cell_magic_highlight['magic_fortran'] = {'reg':[/^%%fortran/]};});












In [36]:

    
%%fortran
RECURSIVE SUBROUTINE ffib(n, fibo)  
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: n
    INTEGER, INTENT(OUT) :: fibo
    INTEGER :: tmp
    IF (n &lt;= 2) THEN 
        fibo = 1
    ELSE
        CALL ffib(n-1,fibo)
        CALL ffib(n-2,tmp)
        fibo = fibo + tmp
    END IF
END SUBROUTINE ffib


    






In [37]:

    
[ffib(x) for x in range(1,10)]


    









    Out[37]:





[1, 1, 2, 3, 5, 8, 13, 21, 34]











No surprise here, you are well aware of what we are doing.







Cython¶






IPython used to ship with the Cython magic that is now part of Cython itself.
Cython is a superset of Python that compiles to C and importable from Python. You should be a ble to take your python code as is, type annotate it, and get c-like speed.
The same principle applies:






In [38]:

    
import cython


    






In [39]:

    
%load_ext cython


    






In [40]:

    
%%cython

def cyfib(int n): # note the `int` here
    """
    A simple definition of fibonacci manually unrolled
    """
    cdef int x,y # and the `cdef int x,y` here
    if n &lt; 2:
        return 1
    x,y = 1,1
    for i in range(n-2):
        x,y = y,x+y
    return y


    






In [41]:

    
[cyfib(x) for x in range(1,10)]


    









    Out[41]:





[1, 1, 2, 3, 5, 8, 13, 21, 34]











benchmark¶





In [42]:

    
%timeit -n100 -r3 fib(5)


    









    



100 loops, best of 3: 648 ns per loop










In [43]:

    
%timeit -n100 -r3 cfib(5)


    









    



The slowest run took 11.60 times longer than the fastest. This could mean that an intermediate result is being cached.
100 loops, best of 3: 578 ns per loop










In [44]:

    
%timeit -n100 -r3 ffib(5)


    









    



100 loops, best of 3: 147 ns per loop










In [45]:

    
%timeit -n100 -r3 cyfib(5)


    









    



100 loops, best of 3: 45.6 ns per loop











The benchmark result can be astonishing, but keep in mind that the Python and Cython version use manually unrolled loop. Main point being that we reached our goal and used Fortran, Cython, C (and Rust) in the middle of our Python program.







[let's skip the Rust fib version, it tends to segfault, and it would be sad to segfault now :-) ]






In [46]:

    
# %timeit rfib(10)


    







The Cake is not a lie!¶






So can we do a layer cake? Can we call rust from Python from Fortran from Cython? Or Cython from C from Fortran? Or Fortron from Cytran from Cust?






In [47]:

    
import itertools
lookup = {'c':cfib,
       # 'rust': rfib, # as before Rust may segfault, but I dont' know why ...
       'python': fib,
       'fortran': ffib,
       'cython': cyfib
         }

print("Pray the demo-gods it wont segfault even without rust...")


    









    



Pray the demo-gods it wont segfault even without rust...










In [48]:

    
for function in lookup.values():
    assert function(5) == 5, "Make sure all is correct or will use 100% CPU for a looong time."


    






In [49]:

    
for order in itertools.permutations(lookup):
    t = 5
    for f in order:
        t = lookup[f](t)
    
    print(' -&gt; '.join(order), ':', t)


    









    



fortran -&gt; cython -&gt; python -&gt; c : 5
fortran -&gt; cython -&gt; c -&gt; python : 5
fortran -&gt; python -&gt; cython -&gt; c : 5
fortran -&gt; python -&gt; c -&gt; cython : 5
fortran -&gt; c -&gt; cython -&gt; python : 5
fortran -&gt; c -&gt; python -&gt; cython : 5
cython -&gt; fortran -&gt; python -&gt; c : 5
cython -&gt; fortran -&gt; c -&gt; python : 5
cython -&gt; python -&gt; fortran -&gt; c : 5
cython -&gt; python -&gt; c -&gt; fortran : 5
cython -&gt; c -&gt; fortran -&gt; python : 5
cython -&gt; c -&gt; python -&gt; fortran : 5
python -&gt; fortran -&gt; cython -&gt; c : 5
python -&gt; fortran -&gt; c -&gt; cython : 5
python -&gt; cython -&gt; fortran -&gt; c : 5
python -&gt; cython -&gt; c -&gt; fortran : 5
python -&gt; c -&gt; fortran -&gt; cython : 5
python -&gt; c -&gt; cython -&gt; fortran : 5
c -&gt; fortran -&gt; cython -&gt; python : 5
c -&gt; fortran -&gt; python -&gt; cython : 5
c -&gt; cython -&gt; fortran -&gt; python : 5
c -&gt; cython -&gt; python -&gt; fortran : 5
c -&gt; python -&gt; fortran -&gt; cython : 5
c -&gt; python -&gt; cython -&gt; fortran : 5










In [50]:

    
print('It worked ! I can run all the permutations !')


    









    



It worked ! I can run all the permutations !











The Cherry on the Layer Cake, with Julia¶






If you have a small idea about how the above layer-cake is working you'll understand that there is (still) a non-negligible overhead as between each language switch we need to go back to Python-land. And the scope in which we can access function is still quite limited. The following is some really Dark Magic concocted by Fernando Perez and Steven Johnson using the Julia programming language. I can't even pretend to understand how this possible, but it's really impressive to see.







Let's try to handwave what's happening. I would be happy to get corrections.







The crux is that the Python and Julia interpreters can be started in a way where they each have access to the other process memory. Thus the Julia and Python interpreter can share live objects. You then "just" need to teach the Julia language about the structure of Python objects and it can manipulate these as desired, either directly (if the memory layout allow it) or using proxy objects that "delegate" the functionality to the python process.
The result being that Julia can import and use Python modules (using the Julia PyCall package), and Julia functions are available from within Python using the pyjulia module.
Let's see how this look like.






In [51]:

    
%matplotlib inline


    






In [52]:

    
%load_ext julia.magic


    









    



Initializing Julia interpreter. This may take some time...










In [53]:

    
julia_version = %julia VERSION
julia_version # you can see this is a wrapper


    









    Out[53]:





<pycall.jlwrap>











He we tell the julia process to import the python matplotlib module, as well as numpy.






In [54]:

    
%julia @pyimport matplotlib.pyplot as plt


    






In [55]:

    
%julia @pyimport numpy as np


    






In [56]:

    
%%julia
                                        # Note how we mix numpy and julia:
t = linspace(0, 2*pi,1000);             # use the julia `linspace` and `pi`
s = sin(3*t + 4*np.cos(2*t));           # use the numpy cosine and julia sine
fig = plt.gcf()                         # **** WATCH THIS VARIABLE ****
plt.plot(t, s, color="red", linewidth=2.0, linestyle="--", label="sin(3t+4.cos(2t))")


    









    Out[56]:





[<matplotlib.lines.line2d at>]






    

















All the above block of code is Julia, where, linspace,pi,sin  are builtins of Julia. np.* and plt.* are referencing Python function and methods.
We see that t is a Julia "Array" (technically a 1000-element LinSpace{Float64}), which can get sent to numpy.cos, multiply by a Julia int, (..etc) and end up being plotted via matplotlib (Python), and displayed inline.
Let's finish our graph in Python






In [57]:

    
import numpy as np
fig = %julia fig
fig.axes[0].plot(X[:6], np.log(Y[:6]), '--', label='fib')
fig.axes[0].set_title('A weird Julia function and Fib')
fig.axes[0].legend()

fig


    









    Out[57]:

















Above we get the reference to our previously defined figure (in Julia), plot the log of our fib function.
The key value here is that we get the same object from within Python and Julia. But let's push even further.







Above we had explicit transition between the Julia code and the Python code. Can we be more sneaky?
One toy example is to define the Fibonacci function using the recursive form and explicitly pass the function with which we recurse.
We'll define such a function both on the Julia and Python side, ask the Julia function to recurse by calling the Python one, and the Python one to recurse using the Julia one.
Let's print (P when we enter Python Kingdom, (J when we enter Julia Realm, and close the parenthesis accordingly:






In [58]:

    
from __future__ import print_function


# julia fib function
jlfib = %julia _fib(n, pyfib) = n &lt;= 2 ? 1 : pyfib(n-1, _fib) + pyfib(n-2, _fib)


def pyfib(n, _fib):
    """
    Python fib function
    """
    print('(P', end='')
    if n &lt;= 2:
         r = 1
    else:
        print('(J', end='')
        # here we tell julia (_fib) to recurse using Python
        r =  _fib(n-1, pyfib) + _fib(n-2, pyfib)
        print(')',end='')
    print(')',end='')
    return r


    






In [59]:

    
fibonacci = lambda x: pyfib(x, jlfib)

fibonacci(10)


    









    



(P(J(P(J(P(J(P(J(P)(P)))(P(J))(P(J))(P)))(P(J(P(J))(P)(P)(P)))(P(J(P(J))(P)(P)(P)))(P(J(P)(P)))))(P(J(P(J(P(J))(P)(P)(P)))(P(J(P)(P)))(P(J(P)(P)))(P(J))))(P(J(P(J(P(J))(P)(P)(P)))(P(J(P)(P)))(P(J(P)(P)))(P(J))))(P(J(P(J(P)(P)))(P(J))(P(J))(P)))))





    Out[59]:





55











Cross language is Easy¶






I hope you enjoyed that, I find it quite interesting and useful when you need to leverage the tools available across multiple domains. I'm sure there are plenty of other tools that allow this kind of things and a host of other languages that can interact with each other in this way.
From the top of my head I know of a few magics (SQL, Redis...) that provide such integration. Every language has its strong and weak points, and knowing what to use is often hard. I hope I convinced you that mixing languages is not such a daunting task.
The other case when this is useful is when you are learning a new language, you can leverage your current expertise temporarily and get something that work before learning the idiomatic way and available libraries.







Comments¶If you have comments suggestions please open an issue on GitHub







Cat Tax¶






Here is a Fibonacci cat to thank you from reading until the end, sorry, no banana for scale.






In [60]:

    
from IPython.display import Image
print('Pfiew')
Image('http://static.boredpanda.com/blog/wp-content/uploads/2016/02/fibonacci-composition-cats-furbonacci-91__700.jpg')


    









    



Pfiew






    Out[60]:
            </matplotlib.lines.line2d></pycall.jlwrap></matplotlib.text.text>
</div>
        </div>
        <div class="post">
            <h1 class="title"><a href="posts/22-one-less-pull-request-followup.md/">One less Pull Request Followup</a></h1>
            <div class="meta">
                <div class="authordate">
                    <time class="timeago" datetime="2016-09-27T20:00:00+00:00">2016-09-27 20:00</time>
</div>
                <div class="stats">
                    
                </div>
                
            </div>
            <div class="body">
                My earlier blog post could not have been more timely, here is what I received
this morning:

Hacktoberfest is back! Ready to hack away?
It’s that time of year again! Hacktoberfest
2016 is right around the corner and
we’re back with new, featured projects and the chance to win the
limited-edition Hacktoberfest T-shirt you all love. 
Read the blog
post to
see what’s changed this year and share on your favorite social media networks
with #Hacktoberfest.

Community Feedback.
I quickly got some feedback in particular from Aaron
Meurer. First there is
no comment box on this blog. I tried it's painful to maintain, need moderation
(...etc) so you can ping me on twitter, or open a
GitHub. I think it's a high
enough filter, if you have something to say to what I write here, you (likely)
already have a GitHub account.
Also, I ran a poll on
twitter, with 41 responses, 51% (I assume 21 users) prefer few PRs. 49% (20
users) don't really count. So there is definitively a non-negligible population
that will still be ok to contribute. This also explains Aaron tweet:

if the number of pull requests discouraged pull requests we wouldn't have so
many pull requests

I would argue that if 50% of your users are not discouraged, you still
discourage the other half. Which might be fine according to your own metrics. 
How to close ?
Aaron expressed his concern that closing a PR without a comment might send the
unintended message that:

The maintainer does not want your code (assuming the maintainer closes)
The Author does not want the project to get his code anymore (assuming the
    author closes)

It might not have been clear enough in earlier post but when closing please,
explain why you are closing, and what you expect. Here is one example of the
IPython repository where the
maintainers have close the PR:

@takluyver and @ellisonbg have decided that we are going to close this PR and
open an issue. We are still interested in this work going in, but the tests
need to be written first. Feel free to re-open when the tests are ready.

If you are closing your own work, please make it clear whether:

You plan to work later on that
If what you did can be reuse by future developers.

When not to close
Aaron pointed again that as a maintainer he prefers to keep PRs open. Now that
GitHub allows you to give maintainers ability to push on your branch, You can
give maintainers the ability to push on the PR. In case you disagree whether
the PR should be close or not, exchange with the maintainer. The commits of a
close PR can still be accessed and maybe a best course of action is for the
maintainer to for your branch and re-issue the PR. They will have more control
over it. Regardless discuss with the maintainer, convey your intent. 
Look deeper into maintainers habits.
I purposely avoided the subject, but Andreas
Mueller pointed out
that you can actually look at recently merged PRs, and commit history. Only if
all PR are old is Andreas discouraged. 
This is a valid strategy, but it requires time from the person that want to
submit the PR. And it's not always easy to do. I tend to go this extra step
when I really think the PR is worth it. 
Things are subjective
Again, all these are personal thoughts and preferences. I prefer to have few
PR, like I would prefer to have zero-inbox. I would be curious to see analysis
of general type of contribution vs number of opened PRs. Are novice users
less likely to contribute depending on the number of opened PRs? Are the
structures of networks across project different ?
Happy HacktoberFest.
            </div>
        </div>
            <nav class="postindexpager"><ul class="pager">
<li class="previous">
                <a href="." rel="prev">Newer posts</a>
            </li>
            <li class="next">
                <a href="index-2.html" rel="next">Older posts</a>
            </li>
        </ul></nav><footer id="footer"><p>Contents © 2021         <a href="mailto:bussonniermatthias+blog@gmail.com">Matthias Bussonnier</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         
<a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/80x15.png"></a><br>This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a> (Contact me to waive NC).
</p>
            
        </footer>
</div>
    </section><script src="assets/js/jquery-1.10.2.min.js" type="text/javascript"></script><script src="assets/js/jquery.timeago.js" type="text/javascript"></script><script src="assets/js/mathjax.js" type="text/javascript"></script><script type="text/javascript">
            $(function(){
                $('.timeago').timeago();
            });
        </script><!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=UA-110089201-1"></script><script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());

          gtag('config', 'UA-110089201-1');
        </script>
</body>
</html>

